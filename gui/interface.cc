// SPDX-License-Identifier: GPL-2.0-or-later
// Copyright (c) 2020 Association Prologin <association@prologin.org>

// This file contains the code to call the API functions from the Python
// language.
// This file was generated by stechec2-generator. DO NOT EDIT.

#include <Python.h>
#include <vector>
#include <string>

static PyObject* py_module;
static PyObject* champ_module;


/// Type de bateau
typedef enum bateau_type
{
    BATEAU_CARAVELLE, ///< Caravelle
    BATEAU_GALION, ///< Galion
    BATEAU_ERREUR, ///< Bateau inexistant
} bateau_type;

/// Type de terrain
typedef enum terrain
{
    TERRAIN_ILE, ///< Île
    TERRAIN_VOLCAN, ///< Volcan
    TERRAIN_MER, ///< Mer
    TERRAIN_ERREUR, ///< Erreur, case impossible
} terrain;

/// Erreurs possibles
typedef enum erreur
{
    OK, ///< L'action a été exécutée avec succès
    OR_INSUFFISANT, ///< Vous ne possédez pas assez d'or pour cette action
    ILE_INVALIDE, ///< La position spécifiée n'est pas une île
    POSITION_INVALIDE, ///< La position spécifiée n'est pas valide
    TROP_LOIN, ///< La destination est trop éloignée
    ILE_COLONISEE, ///< L'île est déjà colonisée
    ILE_ENNEMIE, ///< L'île ne vous appartient pas
    BATEAU_ENNEMI, ///< Le bateau ne vous appartient pas
    ID_INVALIDE, ///< L'ID spécifiée n'est pas valide
    NON_DEPLACABLE, ///< Le bateau n'est pas déplaçable
    AUCUNE_CARAVELLE, ///< Il n'y a aucune caravelle susceptible de coloniser l'île
    LIMITE_ATTEINTE, ///< La limite de bateaux est atteinte
} erreur;

/// Représente la position sur la carte
typedef struct position
{
    int x; ///< Coordonnée en X
    int y; ///< Coordonnée en Y
} position;

/// Représente un bateau
typedef struct bateau
{
    int id; ///< Identifiant unique du bateau
    position pos; ///< Position
    int joueur; ///< Joueur
    bateau_type btype; ///< Type
    int nb_or; ///< Or contenu dans le bateau
    bool deplacable; ///< Le bateau n'a pas encore été déplacé ce tour-ci
} bateau;

extern "C" {

/// Retourne la nature du terrain désigné par ``pos``.
terrain api_info_terrain(position pos);

/// Retourne le joueur qui possède l'île à l'emplacement ``pos``. Retourne -1
/// si l'île est libre ou si la position indiquée n'est pas une île
int api_info_ile_joueur(position pos);

/// Retourne l'or contenu sur l'île à l'emplacement ``pos``. Retourne -1 si la
/// case spécifiée n'est pas une île.
int api_info_ile_or(position pos);

/// Retourne le bateau ayant pour identifiant ``id``
bateau api_info_bateau(int id);

/// Retourne vrai si le bateau ayant pour identifiant ``id`` existe et est
/// encore à flots
bool api_bateau_existe(int id);

/// Retourne la liste de bateaux à la position ``pos``
std::vector<bateau> api_liste_bateaux_position(position pos);

/// Retourne la liste des ID des bateaux à la position ``pos``
std::vector<int> api_liste_id_bateaux_position(position pos);

/// Retourne la liste des positions des îles de la carte
std::vector<position> api_liste_iles();

/// Retourne la liste des positions des îles qui vous appartiennent
std::vector<position> api_mes_iles();

/// Retourne l'ID du dernier bateau construit. Son comportement n'est pas
/// défini si vous n'avez pas encore créé de bateau à ce tour-ci.
int api_id_dernier_bateau_construit();

/// Retourne la distance entre deux positions
int api_distance(position depart, position arrivee);

/// Construire un bateau de type ``btype`` sur l'île à la position ``pos``
erreur api_construire(bateau_type btype, position pos);

/// Déplace le bateau représenté par l'identifiant ``id`` jusqu'à la position
/// `pos`` (si elle est dans la portée du bateau)
erreur api_deplacer(int id, position pos);

/// Colonise l'île à la position ``pos``
erreur api_coloniser(position pos);

/// Charge la caravelle identifiée par ``id`` de ``nb_or`` d'or.
erreur api_charger(int id, int nb_or);

/// Décharge la caravelle identifiée par ``id`` de ``nb_or`` d'or.
erreur api_decharger(int id, int nb_or);

/// Transfère ``montant`` or de la caravelle ``id_source`` à la caravelle
/// ``id_dest``
erreur api_transferer(int montant, int id_source, int id_dest);

/// Retourne le numéro de votre joueur
int api_mon_joueur();

/// Retourne le numéro de votre adversaire
int api_adversaire();

/// Retourne les scores du joueur désigné par l'identifiant ``id``
int api_score(int id_joueur);

/// Retourne le numéro du tour actuel
int api_tour_actuel();

/// Retourne le nombre de bateaux que possède le joueur désigné par
/// l'identifiant ``id``
int api_nombre_bateaux(int id_joueur);

/// Affiche le contenu d'une valeur de type bateau_type
void api_afficher_bateau_type(bateau_type v);

/// Affiche le contenu d'une valeur de type terrain
void api_afficher_terrain(terrain v);

/// Affiche le contenu d'une valeur de type erreur
void api_afficher_erreur(erreur v);

/// Affiche le contenu d'une valeur de type position
void api_afficher_position(position v);

/// Affiche le contenu d'une valeur de type bateau
void api_afficher_bateau(bateau v);

const char* api_get_dump();
}

template <typename PythonType, typename CxxType>
PythonType cxx_to_python(CxxType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
PyObject* cxx_to_python<PyObject*, int>(int in)
{
    return PyLong_FromLong(in);
}


template <>
PyObject* cxx_to_python<PyObject*, double>(double in)
{
    return PyFloat_FromDouble(in);
}


template <>
PyObject* cxx_to_python<PyObject*, std::string>(std::string in)
{
    return PyUnicode_FromString(in.c_str());
}


template <>
PyObject* cxx_to_python<PyObject*, bool>(bool in)
{
    return PyBool_FromLong(in);
}

template <typename CxxType>
PyObject* cxx_to_python_array(const std::vector<CxxType>& in)
{
    size_t size = in.size();
    PyObject* out = PyList_New(size);

    for (unsigned int i = 0; i < size; ++i)
        PyList_SET_ITEM(out, i, (cxx_to_python<PyObject*, CxxType>(in[i])));

    return out;
}

template <typename PythonType, typename CxxType>
CxxType python_to_cxx(PythonType in)
{
    return in.__if_that_triggers_an_error_there_is_a_problem;
}

template <>
int python_to_cxx<PyObject*, int>(PyObject* in)
{
    long out = PyLong_AsLong(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
double python_to_cxx<PyObject*, double>(PyObject* in)
{
    double out = PyFloat_AsDouble(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <>
bool python_to_cxx<PyObject*, bool>(PyObject* in)
{
    return static_cast<bool>(python_to_cxx<PyObject*, int>(in));
}

template <>
std::string python_to_cxx<PyObject*, std::string>(PyObject* in)
{
    const char* out = PyUnicode_AsUTF8(in);
    if (PyErr_Occurred())
        throw 42;
    return out;
}

template <typename CxxType>
std::vector<CxxType> python_to_cxx_array(PyObject* in)
{
    if (!PyList_Check(in))
    {
        PyErr_SetString(PyExc_TypeError, "a list is required");
        throw 42;
    }

    std::vector<CxxType> out;
    unsigned int size = PyList_Size(in);
    out.reserve(size);

    for (unsigned int i = 0; i < size; ++i)
        out.push_back(python_to_cxx<PyObject*, CxxType>(PyList_GET_ITEM(in, i)));

    return out;
}

// Type de bateau

template<>
PyObject* cxx_to_python<PyObject*, bateau_type>(bateau_type in)
{
    PyObject* name = PyUnicode_FromString("bateau_type");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
bateau_type python_to_cxx<PyObject*, bateau_type>(PyObject* in)
{
    return static_cast<bateau_type>(python_to_cxx<PyObject*, int>(in));
}

// Type de terrain

template<>
PyObject* cxx_to_python<PyObject*, terrain>(terrain in)
{
    PyObject* name = PyUnicode_FromString("terrain");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
terrain python_to_cxx<PyObject*, terrain>(PyObject* in)
{
    return static_cast<terrain>(python_to_cxx<PyObject*, int>(in));
}

// Erreurs possibles

template<>
PyObject* cxx_to_python<PyObject*, erreur>(erreur in)
{
    PyObject* name = PyUnicode_FromString("erreur");
    PyObject* enm = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (enm == nullptr)
        throw 42;
    PyObject* arglist = Py_BuildValue("(i)", static_cast<int>(in));
    PyObject* ret = PyObject_CallObject(enm, arglist);
    Py_DECREF(enm);
    Py_DECREF(arglist);
    return ret;
}

template <>
erreur python_to_cxx<PyObject*, erreur>(PyObject* in)
{
    return static_cast<erreur>(python_to_cxx<PyObject*, int>(in));
}

// Représente la position sur la carte

template <>
PyObject* cxx_to_python<PyObject*, position>(position in)
{
    PyObject* tuple = PyTuple_New(2);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.x)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, int>(in.y)));
    return tuple;
}

template <>
position python_to_cxx<PyObject*, position>(PyObject* in)
{
    position out;
    PyObject* i;

    // Coordonnée en X
    i = PyTuple_GetItem(in, 0);
    if (i == nullptr)
        throw 42;
    out.x = python_to_cxx<PyObject*, int>(i);

    // Coordonnée en Y
    i = PyTuple_GetItem(in, 1);
    if (i == nullptr)
        throw 42;
    out.y = python_to_cxx<PyObject*, int>(i);

    return out;
}

// Représente un bateau

template <>
PyObject* cxx_to_python<PyObject*, bateau>(bateau in)
{
    PyObject* tuple = PyTuple_New(6);
    PyTuple_SET_ITEM(tuple, 0, (cxx_to_python<PyObject*, int>(in.id)));
    PyTuple_SET_ITEM(tuple, 1, (cxx_to_python<PyObject*, position>(in.pos)));
    PyTuple_SET_ITEM(tuple, 2, (cxx_to_python<PyObject*, int>(in.joueur)));
    PyTuple_SET_ITEM(tuple, 3, (cxx_to_python<PyObject*, bateau_type>(in.btype)));
    PyTuple_SET_ITEM(tuple, 4, (cxx_to_python<PyObject*, int>(in.nb_or)));
    PyTuple_SET_ITEM(tuple, 5, (cxx_to_python<PyObject*, bool>(in.deplacable)));
    PyObject* name = PyUnicode_FromString("bateau");
    PyObject* cstr = PyObject_GetAttr(py_module, name);
    Py_DECREF(name);
    if (cstr == nullptr)
        throw 42;
    PyObject* ret = PyObject_CallObject(cstr, tuple);
    Py_DECREF(cstr);
    Py_DECREF(tuple);
    if (ret == nullptr)
        throw 42;
    return ret;
}

template <>
bateau python_to_cxx<PyObject*, bateau>(PyObject* in)
{
    bateau out;
    PyObject* i;

    // Identifiant unique du bateau
    i = cxx_to_python<PyObject*, int>(0);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.id = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Position
    i = cxx_to_python<PyObject*, int>(1);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.pos = python_to_cxx<PyObject*, position>(i);
    Py_DECREF(i);

    // Joueur
    i = cxx_to_python<PyObject*, int>(2);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.joueur = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Type
    i = cxx_to_python<PyObject*, int>(3);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.btype = python_to_cxx<PyObject*, bateau_type>(i);
    Py_DECREF(i);

    // Or contenu dans le bateau
    i = cxx_to_python<PyObject*, int>(4);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.nb_or = python_to_cxx<PyObject*, int>(i);
    Py_DECREF(i);

    // Le bateau n'a pas encore été déplacé ce tour-ci
    i = cxx_to_python<PyObject*, int>(5);
    i = PyObject_GetItem(in, i);
    if (i == nullptr)
        throw 42;
    out.deplacable = python_to_cxx<PyObject*, bool>(i);
    Py_DECREF(i);

    return out;
}


// Python native wrapper for function info_terrain.
// Retourne la nature du terrain désigné par ``pos``.
static PyObject* p_info_terrain(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, terrain>(api_info_terrain(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_ile_joueur.
// Retourne le joueur qui possède l'île à l'emplacement ``pos``. Retourne -1 si
// l'île est libre ou si la position indiquée n'est pas une île
static PyObject* p_info_ile_joueur(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_info_ile_joueur(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_ile_or.
// Retourne l'or contenu sur l'île à l'emplacement ``pos``. Retourne -1 si la
// case spécifiée n'est pas une île.
static PyObject* p_info_ile_or(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_info_ile_or(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function info_bateau.
// Retourne le bateau ayant pour identifiant ``id``
static PyObject* p_info_bateau(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id;
    if (!PyArg_ParseTuple(args, "O", &arg_id))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, bateau>(api_info_bateau(python_to_cxx<PyObject*, int>(arg_id)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function bateau_existe.
// Retourne vrai si le bateau ayant pour identifiant ``id`` existe et est
// encore à flots
static PyObject* p_bateau_existe(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id;
    if (!PyArg_ParseTuple(args, "O", &arg_id))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, bool>(api_bateau_existe(python_to_cxx<PyObject*, int>(arg_id)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function liste_bateaux_position.
// Retourne la liste de bateaux à la position ``pos``
static PyObject* p_liste_bateaux_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_liste_bateaux_position(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function liste_id_bateaux_position.
// Retourne la liste des ID des bateaux à la position ``pos``
static PyObject* p_liste_id_bateaux_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_liste_id_bateaux_position(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function liste_iles.
// Retourne la liste des positions des îles de la carte
static PyObject* p_liste_iles(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_liste_iles());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function mes_iles.
// Retourne la liste des positions des îles qui vous appartiennent
static PyObject* p_mes_iles(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python_array(api_mes_iles());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function id_dernier_bateau_construit.
// Retourne l'ID du dernier bateau construit. Son comportement n'est pas défini
// si vous n'avez pas encore créé de bateau à ce tour-ci.
static PyObject* p_id_dernier_bateau_construit(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_id_dernier_bateau_construit());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function distance.
// Retourne la distance entre deux positions
static PyObject* p_distance(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_depart;
    PyObject* arg_arrivee;
    if (!PyArg_ParseTuple(args, "OO", &arg_depart, &arg_arrivee))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_distance(python_to_cxx<PyObject*, position>(arg_depart), python_to_cxx<PyObject*, position>(arg_arrivee)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function construire.
// Construire un bateau de type ``btype`` sur l'île à la position ``pos``
static PyObject* p_construire(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_btype;
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "OO", &arg_btype, &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_construire(python_to_cxx<PyObject*, bateau_type>(arg_btype), python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function deplacer.
// Déplace le bateau représenté par l'identifiant ``id`` jusqu'à la position
// `pos`` (si elle est dans la portée du bateau)
static PyObject* p_deplacer(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id;
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "OO", &arg_id, &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_deplacer(python_to_cxx<PyObject*, int>(arg_id), python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function coloniser.
// Colonise l'île à la position ``pos``
static PyObject* p_coloniser(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_pos;
    if (!PyArg_ParseTuple(args, "O", &arg_pos))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_coloniser(python_to_cxx<PyObject*, position>(arg_pos)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function charger.
// Charge la caravelle identifiée par ``id`` de ``nb_or`` d'or.
static PyObject* p_charger(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id;
    PyObject* arg_nb_or;
    if (!PyArg_ParseTuple(args, "OO", &arg_id, &arg_nb_or))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_charger(python_to_cxx<PyObject*, int>(arg_id), python_to_cxx<PyObject*, int>(arg_nb_or)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function decharger.
// Décharge la caravelle identifiée par ``id`` de ``nb_or`` d'or.
static PyObject* p_decharger(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id;
    PyObject* arg_nb_or;
    if (!PyArg_ParseTuple(args, "OO", &arg_id, &arg_nb_or))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_decharger(python_to_cxx<PyObject*, int>(arg_id), python_to_cxx<PyObject*, int>(arg_nb_or)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function transferer.
// Transfère ``montant`` or de la caravelle ``id_source`` à la caravelle
// ``id_dest``
static PyObject* p_transferer(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_montant;
    PyObject* arg_id_source;
    PyObject* arg_id_dest;
    if (!PyArg_ParseTuple(args, "OOO", &arg_montant, &arg_id_source, &arg_id_dest))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, erreur>(api_transferer(python_to_cxx<PyObject*, int>(arg_montant), python_to_cxx<PyObject*, int>(arg_id_source), python_to_cxx<PyObject*, int>(arg_id_dest)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function mon_joueur.
// Retourne le numéro de votre joueur
static PyObject* p_mon_joueur(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_mon_joueur());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function adversaire.
// Retourne le numéro de votre adversaire
static PyObject* p_adversaire(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_adversaire());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function score.
// Retourne les scores du joueur désigné par l'identifiant ``id``
static PyObject* p_score(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id_joueur;
    if (!PyArg_ParseTuple(args, "O", &arg_id_joueur))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_score(python_to_cxx<PyObject*, int>(arg_id_joueur)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function tour_actuel.
// Retourne le numéro du tour actuel
static PyObject* p_tour_actuel(PyObject* /* self */, PyObject* args)
{
    if (!PyArg_ParseTuple(args, ""))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_tour_actuel());
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function nombre_bateaux.
// Retourne le nombre de bateaux que possède le joueur désigné par
// l'identifiant ``id``
static PyObject* p_nombre_bateaux(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_id_joueur;
    if (!PyArg_ParseTuple(args, "O", &arg_id_joueur))
    {
        return nullptr;
    }

    try {
        return cxx_to_python<PyObject*, int>(api_nombre_bateaux(python_to_cxx<PyObject*, int>(arg_id_joueur)));
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_bateau_type.
// Affiche le contenu d'une valeur de type bateau_type
static PyObject* p_afficher_bateau_type(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_bateau_type(python_to_cxx<PyObject*, bateau_type>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_terrain.
// Affiche le contenu d'une valeur de type terrain
static PyObject* p_afficher_terrain(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_terrain(python_to_cxx<PyObject*, terrain>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_erreur.
// Affiche le contenu d'une valeur de type erreur
static PyObject* p_afficher_erreur(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_erreur(python_to_cxx<PyObject*, erreur>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_position.
// Affiche le contenu d'une valeur de type position
static PyObject* p_afficher_position(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_position(python_to_cxx<PyObject*, position>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

// Python native wrapper for function afficher_bateau.
// Affiche le contenu d'une valeur de type bateau
static PyObject* p_afficher_bateau(PyObject* /* self */, PyObject* args)
{
    PyObject* arg_v;
    if (!PyArg_ParseTuple(args, "O", &arg_v))
    {
        return nullptr;
    }

    try {
        (api_afficher_bateau(python_to_cxx<PyObject*, bateau>(arg_v)));
        Py_RETURN_NONE;
    } catch (...) {
        return nullptr;
    }
}

static PyObject* p_get_dump(PyObject* self, PyObject* args)
{
    const char* dump = api_get_dump();
    PyObject* py_dump = PyUnicode_FromString(dump);
    return py_dump;
}

// API function to register.
static PyMethodDef api_callback[] = {
    {"info_terrain", p_info_terrain, METH_VARARGS, "info_terrain"},
    {"info_ile_joueur", p_info_ile_joueur, METH_VARARGS, "info_ile_joueur"},
    {"info_ile_or", p_info_ile_or, METH_VARARGS, "info_ile_or"},
    {"info_bateau", p_info_bateau, METH_VARARGS, "info_bateau"},
    {"bateau_existe", p_bateau_existe, METH_VARARGS, "bateau_existe"},
    {"liste_bateaux_position", p_liste_bateaux_position, METH_VARARGS, "liste_bateaux_position"},
    {"liste_id_bateaux_position", p_liste_id_bateaux_position, METH_VARARGS, "liste_id_bateaux_position"},
    {"liste_iles", p_liste_iles, METH_VARARGS, "liste_iles"},
    {"mes_iles", p_mes_iles, METH_VARARGS, "mes_iles"},
    {"id_dernier_bateau_construit", p_id_dernier_bateau_construit, METH_VARARGS, "id_dernier_bateau_construit"},
    {"distance", p_distance, METH_VARARGS, "distance"},
    {"construire", p_construire, METH_VARARGS, "construire"},
    {"deplacer", p_deplacer, METH_VARARGS, "deplacer"},
    {"coloniser", p_coloniser, METH_VARARGS, "coloniser"},
    {"charger", p_charger, METH_VARARGS, "charger"},
    {"decharger", p_decharger, METH_VARARGS, "decharger"},
    {"transferer", p_transferer, METH_VARARGS, "transferer"},
    {"mon_joueur", p_mon_joueur, METH_VARARGS, "mon_joueur"},
    {"adversaire", p_adversaire, METH_VARARGS, "adversaire"},
    {"score", p_score, METH_VARARGS, "score"},
    {"tour_actuel", p_tour_actuel, METH_VARARGS, "tour_actuel"},
    {"nombre_bateaux", p_nombre_bateaux, METH_VARARGS, "nombre_bateaux"},
    {"afficher_bateau_type", p_afficher_bateau_type, METH_VARARGS, "afficher_bateau_type"},
    {"afficher_terrain", p_afficher_terrain, METH_VARARGS, "afficher_terrain"},
    {"afficher_erreur", p_afficher_erreur, METH_VARARGS, "afficher_erreur"},
    {"afficher_position", p_afficher_position, METH_VARARGS, "afficher_position"},
    {"afficher_bateau", p_afficher_bateau, METH_VARARGS, "afficher_bateau"},
    {"get_dump", p_get_dump, METH_VARARGS, "get_dump"},
    {nullptr, nullptr, 0, nullptr}
};

// Initialize C module.
PyMODINIT_FUNC PyInit__api()
{
    static struct PyModuleDef apimoduledef = {
        PyModuleDef_HEAD_INIT,
        "_api",
        "API module",
        -1,
        api_callback,
        nullptr,
        nullptr,
        nullptr,
        nullptr,
    };
    return PyModule_Create(&apimoduledef);
}

// Load a Python module.
static PyObject* _import_module(const char* m)
{
    PyObject* name = PyUnicode_FromString(m);
    PyObject* mod = PyImport_Import(name);
    Py_DECREF(name);
    if (mod == nullptr)
        if (PyErr_Occurred())
        {
            PyErr_Print();
            abort();
        }
    return mod;
}

// Initialize Python VM, register API functions, and load .py file.
static void _init_python()
{
    static wchar_t empty_string[] = L"";
    static wchar_t *argv[] = { (wchar_t *) &empty_string, nullptr };

    const char* champion_path;

    champion_path = getenv("CHAMPION_PATH");
    if (champion_path == nullptr)
        champion_path = ".";

    setenv("PYTHONPATH", champion_path, 1);

    static wchar_t program_name[] = L"stechec";
    Py_SetProgramName(program_name);

    PyImport_AppendInittab("_api", PyInit__api);
    Py_Initialize();
    PySys_SetArgvEx(1, argv, 0);

    // Import a Champion module with an uppercase letter to avoid conflict with
    // champion.so
    champ_module = _import_module("Champion");
    py_module = _import_module("api");
}

// Flush stdout and stderr
static void flush_std_files()
{
    PyObject *fout = PySys_GetObject("stdout");
    PyObject *ferr = PySys_GetObject("stderr");
    PyObject *tmp;

    if (fout != nullptr && fout != Py_None) {
        tmp = PyObject_CallMethod(fout, "flush", "");
        if (tmp == nullptr)
            PyErr_WriteUnraisable(fout);
        else
            Py_DECREF(tmp);
    }

    if (ferr != nullptr && ferr != Py_None) {
        tmp = PyObject_CallMethod(ferr, "flush", "");
        if (tmp == nullptr)
            PyErr_Clear();
        else
            Py_DECREF(tmp);
    }
}

// Run a Python function.
static PyObject* _call_python_function(const char* name)
{
    static bool initialized = false;

    if (!initialized)
    {
        initialized = true;
        _init_python();
    }

    PyObject *arglist, *func;
    PyObject *result = nullptr;

    func = PyObject_GetAttrString(champ_module, name);
    if (func && PyCallable_Check(func))
    {
        arglist = Py_BuildValue("()");
        result = PyEval_CallObject(func, arglist);
        Py_XDECREF(arglist);
        Py_DECREF(func);
    }
    if (result == nullptr && PyErr_Occurred())
    {
        PyErr_Print();
        abort();
    }

    flush_std_files();
    return result;
}


// Functions called from Stechec to Python.

extern "C" void partie_init()
{
    PyObject* _retval = _call_python_function("partie_init");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void jouer_tour()
{
    PyObject* _retval = _call_python_function("jouer_tour");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}

extern "C" void partie_fin()
{
    PyObject* _retval = _call_python_function("partie_fin");
    try {
        Py_XDECREF(_retval);
    } catch (...) {
        PyErr_Print();
        abort();
    }
}
